## Load balancers
Use cases:
* spread load across multiple downstream instances
* expose a single point of access (DNS) to your application
* seamlessly handle failure of downstream instances
* do regular health-checks  to your instances
* provide SSL termination (HTTPS) for your instances
* enforce stickCross account backups.  ness with cookies
* high availability across zones
* separate public traffic from private traffic

### Load balancer types
* Classic Load Balancer (CLB) - old gen, 4 and 7: HTTP, HTTPS, TCP, SSL (secure TLS), fixed hostname
* Application Load Balancer (ALB) - newer gen, 7: HTTP, HTTPS WebSocket,
* Network Load Balancer (NLB) - newer gen, TCP, TLS (secure TCP), UDP
* Gateway Load Balancer (GWLB) - newer gen, IP (layer 3)

LB can be set up as internal (private) or external (public).

Load balancer SG: allow 80 and 443 from anywhere.
EC2 SG: allow 80 from load balancer SG only!

### Application Load Balancer
Target groups - group of target machines.
* EC2 instances (even from ASG) - HTTP
* ECS tasks - HTTP
* Lambda functions (HTTP request is translated into a JSON event)
* IP address (private)

Load balancing to multiple apps on the same machines (containers),.
Automatically redirect HTTP to HTTPS.
Routing tables to different target groups - based on path in URL: example.com/users & example.com/posts
Routing based on hostname in URL
(one.exaplme.com & two.example.com)
Routing based on Query Strings, Headers:
example.com/users?id=123&order=true

The app servers don’t see client IPs, X-Forwarded-For, X-Forwarded-Port and X-Forwarded-Proto headers must be used.

Listener Rules
Processed in order, default rule on the end.
Weighting target groups - specific weight for each target group on a single rule, eg. multiple versions of your app, blue/green deployment. Allows to control the distribution of the traffic to your applications.

Supported actions:
* forward - to a specific target group
* redirect - to a specific URL
* fixed-response - generate response to client

Rule conditions:
* host-header
* http-request-method
* path-pattern
* source-ip
* http-header
* query-string

### Network Load Balancer
Milion request per second - 100 ms latency (vs 400 ms for ALB).
Forward TCP and UDP traffic to instances.
NLB has one static IP per AZ (instead static hostname) and supports Elastic IP assigning.

NLB target groups:
* EC2 instances
* private IP
* Application Load Balancer

From target perspective incoming traffic looks like from client (no from NLB) so traffic from all sources must be allowed!

### Gateway Load Balancer
Deploy, scale and manage a fleet of 3rd party network virtual appliances (Firewalls, IDS, IPS, Deep packet inspection etc).
Operates at Layer 3 -Network layer (IP).

Combines the following functions:
* Transparent Network Gateway - single entry/exit for all traffic
* Load Balancer - distributes traffic to your virtual appliances.

Uses the GENEVE protocol on port 6081!

Target groups:
* EC2 instances
* IP addresses (private).

### Sticky sessions (session affinity)
The same client is always redirected to the same instance behind load balancer. Works in Classic and Application Load balancers. Uses cookie with expiration date.

Cookie names:
* Application based cookies
	* AWSALBAPP (generated by ALB)
	* Custom cookie - generated by the target instance, individual for each target group. Cannot use reserver names.
* Duration based cookies
	* AWSALB generated by ALB
	* AWSELB generated by CLB

### Cross-Zone Load Balancing
LBs in different AZs - they can distribute load across instances in different than their Availability zones.

Options:
* Application LB - always on (can’t be disabled), no charges for inter AZ data
* Network LB - disabled by default, pay charge for inter AZ data (if enabled)
* Classic Load Balancer - disabled by default, do NOT pay for inter AZ data.

### Connection draining
For CLB - connection draining, for newer gen. (ALB and NLB) - De-registration Delay. Time to complete in-flight requests while instance is de-registering from LB (disabling or unhealthy). LB will stop sending requests to this instance and wait set value of time to complete opened requests. Value can be set 0-3600 seconds (default 300). You should set low value only if your request are short.

### Health Checks
* HealthCheckProtocol - HTTP - protocol used to perform health checks.
* HealthCheckPort - 80 - port used to check
* HealthCheckPath - / - destination on target
* HeathCheckTimeoutSeconds - 5 - check failed if no response after 5s
* HeathCheckIntervalSeconds - 30 - send check every 30s
* HealthyThresholdCount - 3 - target healthy after 3 successful checks
* UnhealthyThresholdCount - 5 - target unhealthy target after 5 failed checks

Status:
* Initial - registering the target
* Healthy
* Unhealthy
* Unused - target is not registered
* Draining - de-registering the target
* Unavailable - health checks disabled

### Metrics:
* BackedconnectionErrors
* Healthy/UnhealthyHostCount
* HTTPCode_Backend_2xx - successful requests
* HTTPCode_Backend_3xx - redirected requests
* HTTPCode_Backend_4xx - client error codes
* HTTPCode_Backend_5xx - server error codes (from LB)
* Latency - how fast clients gets response
* RequestCount
* RequestCountPertarget
* SurgeQueueLength - the total number of requests/connections that are pending routing to healthy instance (help to scale out ASG)
* SpilloverCount - total number of rejected requests (because of full queue)

### Access Logs
Only pay for S3 storage with access logs.

LB logs include:
* time
* client IP
* latencies
* request paths
* server response
* trace ID (X-Amzn-Trace-Id header)

### Target Group Settings
* deregistration_delay.timeout_seconds - time to load balancer waits before deregistering the target
* slow_start.duration_seconds - time to warm-up for instance, number of requests will linearly increase
* load_balancing.algorithm.type - RoundRobin, Least Outstanding Requests
* stickiness.enabled
* stickiness.type - application-based or duration-based cookie
* stickiness.app_cookie.cookie_name - name of the application cookie
* stickiness.app_cookie.duration_seconds - app-based cookie expiration
* stickiness.lb_cookie.duration_seconds - duration-based cookie expiration

### Routing Algorithms:
1. Least Outgoing Requests - the next instance to receive the request is the instance that has the lowest number of pending/unfinished requests. Works for ALB and CLB (HTTPS/HTTPS). The least busy instance!
2. Round Robin - equally chose the targets from the target group. Works with ALB and CLB (TCP).
3. Flow Hash - selects the target based on the protocol, source/destination IP, source/destination port and TCP sequence number. Each TCP/UDP connection is routed to a single target for the life of connection. Works with NLB -  equivalent of sticky sessions.

## SSL
### Server Name Indication (SNI)
Protocol requires from client to indicate the hostname of webpage that is trying to reach during the initial SSL handshake. Works only with new gen. LB (Application , Network, CloudFront). Classic LB supports only 1! SSL cert.

## Auto Scaling Group (ASG)
Services:
* Amazon EC2 Auto Scaling Groups
* Amazon EC2 Spot Fleet Requests (new or interrupted by price)
* Amazon ECS (adjust ECS service desired count up/down)
* Amazon DynamoDB (table or global secondary index)
* Amazon Aurora (Dynamic Read Replicas Auto Scaling)

Launch template (launch configurations) - contains information how to launch instances in AGS:
* MIN size, MAX size, initial capacity
* scaling policies
* AMI + instance type
* EC2 user data
* EBS volumes
* Security groups
* SSH key pair
* IAM roles
* Network + subnet information
* load balancer information

Scale out - to add instances
Scale in - to remove instances

### Dynamic Scaling Policies
1. Target tracking scaling - average ASG CPU must stay at around 40%.
2. Simple/step scaling - when CloudWatch alarm is triggered, eg. CPU > 70%, then add 2 units, when <30, then remove 1 unit.
3. Scheduled actions - known usage patterns, eg. increase capacity to 10 at 5PM on Fridays.
4. Predictive scaling - continuously forecast load and schedule scaling ahead.

### Metrics
* ASG-level (optional)
	* GroupMinSize, GroupMaxSize, GroupDesiredCapacity, GroupInServiceInstances, GroupPendingInstaces, GroupStandbyInstances, GroupTerminatingInstances, GroupTotalInstances
* EC2-level metrics (enabled)
	* Basic: every 5mins
	* Detailed (paid): every 1 minute
	* CPUUtilization, RequestCountPerTarged, Average Network In/Out


### ASG Health Checks
* EC2 status check
* ELB status check
* Custom health check (send check using CLI or SDK: set-instance-health and terminate-instance-in-auto-scaling-group)

ASG always launch a new instance after termination unhealthy one.
ASG cannot reboot unhealthy instances.

Scaling cooldown - after a scaling activity happens, ASG is in the cooldown period. During this, the ASG will not launch or terminate additional instances to allow metrics to stabilize.

### ASG Lifecycle Hook
Vy default as soon as an instance is launched in an ASG group it’s in service.

1. User can perform extra steps before the instance goes in service (pending state) - define a script to run on the instance as they start (eg. prepare instance)

Scale out -> Pending -> Lifecycle hook: EC2_Instance_Launching -> Pending: Wait -> Pending: Proceed -> In service

2. User can perform some actions before instance is terminated - pause the instances for. eg. troubleshooting, extract logs, create EBS snapshot.

In Service -> Scale In -> Terminating -> Lifecycle hook: EC2_Instance_Terminating -> Terminating: Wait -> Terminating; Proceed -> Terminated

Integration wit: Event Bridge (Lambda), SNS, SQS.

### SQS withASG
CloudWatch metric - Queue length (ApproximateNumberOfMessages), if too high -> CloudWatch alarm -> ASG scale out